<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="Just some notes.">
<meta property="og:type" content="website">
<meta property="og:title" content="LT&#39;s Notes">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="LT&#39;s Notes">
<meta property="og:description" content="Just some notes.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LT&#39;s Notes">
<meta name="twitter:description" content="Just some notes.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>LT's Notes</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LT's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">LT's Notes</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/07/Docker常用操作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LT">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/daniuli.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LT's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/07/Docker常用操作/" itemprop="url">Docker常用操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-07T20:56:53+08:00">
                2017-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Docker命令比较多,并且每个命令有很多参数项，这里仅列出比较常用的一些操作（镜像相关、容器相关、调试等），以便有一个直观的印象。</p>
<p>Docker的命令清单可以通过运行 docker，或者 docker help 命令得到。</p>
<h1 id="镜像操作相关"><a href="#镜像操作相关" class="headerlink" title="镜像操作相关"></a>镜像操作相关</h1><h2 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h2><p>我们可以从Docker Hub网站来搜索镜像，Docker Hub 网址为： <a href="https://hub.docker.com/" target="_blank" rel="external">https://hub.docker.com/</a></p>
<p>我们也可以使用 docker search 命令来搜索镜像。</p>
<p>比如我们需要一个mysql的镜像来作为我们的数据库。我们可以通过 docker search 命令搜索 mysql 来寻找适合我们的镜像。</p>
<pre><code>[root@localhost ~]# docker search mysql
NAME       DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
mysql      MySQL is a widely used, open-source relati...   4753      [OK]       
mariadb    MariaDB is a community-developed fork of M...   1463      [OK]       
percona    Percona Server is a fork of the MySQL rela...   283       [OK]     
</code></pre><p>输出字段含义：</p>
<ol>
<li>NAME: 镜像仓库源的名称</li>
<li>DESCRIPTION: 镜像的描述</li>
<li>OFFICIAL: 是否docker官方发布</li>
</ol>
<h2 id="从docker仓库中获取镜像"><a href="#从docker仓库中获取镜像" class="headerlink" title="从docker仓库中获取镜像"></a>从docker仓库中获取镜像</h2><p>使用 docker 必须自少有一个基础镜像包，镜像包可以从公共仓库中获取，也可以搭建私有的镜像仓库。</p>
<p>本例使用 docker 的默认配置，docker pull 命令会自动从docker.io 这个仓库去下载 busybox 镜像包。</p>
<pre><code>[root@localhost ~]# docker pull busybox
Using default tag: latest
latest: Pulling from library/busybox
9e87eff13613: Pull complete 
Digest: sha256:2605a2c4875ce5eb27a9f7403263190cd1af31e48a2044d400320548356251c4
Status: Downloaded newer image for busybox:latest
</code></pre><p>后续我们会搭建私有的镜像仓库。</p>
<h2 id="查看本机的镜像包"><a href="#查看本机的镜像包" class="headerlink" title="查看本机的镜像包"></a>查看本机的镜像包</h2><pre><code>[root@localhost ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
busybox             latest              efe10ee6727f        2 weeks ago         1.13MB
hello-world         latest              1815c82652c0        7 weeks ago         1.84kB
</code></pre><p>通过 docker images 命令，可以查看本机所有的镜像包。这里解释下命令输出中每个字段的意义：</p>
<ol>
<li>REPOSITORY：该字段包括两部分，第一部分是仓库名字（docker.io），第二部分是镜像包的名字。</li>
<li>TAG：用来表征镜像的版本号，默认情况下拖取最新版本（latest），也可以指定镜像的具体版本。</li>
<li>IMAGE_ID：一个哈希值，用来唯一标志一个镜像文件。</li>
<li>CREATED：镜像创建的时间。</li>
<li>VIRTUAL SIZE：镜像的大小。</li>
</ol>
<h2 id="利用镜像包启动容器"><a href="#利用镜像包启动容器" class="headerlink" title="利用镜像包启动容器"></a>利用镜像包启动容器</h2><pre><code>[root@localhost hello]# docker run hello-world

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
1. The Docker client contacted the Docker daemon.
2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.
3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
$ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
https://cloud.docker.com/

For more examples and ideas, visit:
https://docs.docker.com/engine/userguide/
</code></pre><p>docker run 命令的作用是用来启动一个容器。</p>
<p>如上图所示，通过 hello-world 镜像包启动一个容器。</p>
<h2 id="查看镜像包的历史信息"><a href="#查看镜像包的历史信息" class="headerlink" title="查看镜像包的历史信息"></a>查看镜像包的历史信息</h2><p>如前所述，镜像包是累加制作的，通过docker history命令，可以看到当前镜像包的整体叠加构建的历史。</p>
<pre><code>[root@localhost hello]# docker history busybox
IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
efe10ee6727f        2 weeks ago         /bin/sh -c #(nop)  CMD [&quot;sh&quot;]                   0B                  
&lt;missing&gt;           2 weeks ago         /bin/sh -c #(nop) ADD file:0516fc7a5988 ...   1.13MB   
</code></pre><h1 id="容器操作相关"><a href="#容器操作相关" class="headerlink" title="容器操作相关"></a>容器操作相关</h1><h2 id="运行一个带交互的容器"><a href="#运行一个带交互的容器" class="headerlink" title="运行一个带交互的容器"></a>运行一个带交互的容器</h2><pre><code>[root@localhost ~]# docker run -i -t busybox
/ # ls
bin   dev   etc   home  proc  root  sys   tmp   usr   var
/ # 
</code></pre><p>本例中，docker run 的-i 选项使得容器可以接收外部的标准输入，-t 选项使得容器内部开启一个伪终端，加上这两个参数后，就可以通过命令行接口和容器进行交互。</p>
<h2 id="查看运行态容器的信息"><a href="#查看运行态容器的信息" class="headerlink" title="查看运行态容器的信息"></a>查看运行态容器的信息</h2><pre><code>[root@localhost blog]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
1575c6863d8b        busybox             &quot;sh&quot;                3 minutes ago       Up 3 minutes                            keen_fermat
</code></pre><p>docker ps 命令可以查看处于运行态的容器信息，这里解释一下命令输出中各个字段<br>的意义：</p>
<ol>
<li>CNTAINER ID：容器的 ID 号，一个哈希值，用于唯一确认一个容器。</li>
<li>IMAGE： 此容器对应的镜像包。</li>
<li>COMMAND： 该容器启动后，在该容器内运行的最近的一个命令。</li>
<li>CREATED：容器创建的时间。</li>
<li>STAUTS：容器当前的状态。</li>
<li>PORTS：容器所开放的端口（本例未分配端口给该容器）。</li>
<li>NAMES： docker 会给容器随机分配一个名字，以方便引用。也可以通过 run 命令的–name 选项手动指定。</li>
</ol>
<h2 id="跟踪容器对镜像做出的修改"><a href="#跟踪容器对镜像做出的修改" class="headerlink" title="跟踪容器对镜像做出的修改"></a>跟踪容器对镜像做出的修改</h2><pre><code>[root@localhost ~]# docker attach 1575c6863d8b
/ # cd /home
/home # ls
/home # touch test
/home # read escape sequence
[root@localhost ~]# docker diff 1575c6863d8b 
C /home
A /home/test
C /root
A /root/.ash_history
</code></pre><p>docker的底层使用了 AUFS文件系统，镜像包是累进叠加的，最终的镜像被docker run命令生成一个容器后，该容器内部有一个 writable 的区域可以对镜像的内容进行修改，但镜像本身是只读的。</p>
<p>本例描述的过程如下：</p>
<ol>
<li>通过 docker attach 命令附着到正在运行的容器中。</li>
<li>在容器内做一些修改，本例中在/home 目录中新增了一个名为test的文件。</li>
<li>先后执行“ CTRL+P” +“ CTRL +Q”返回到本机 shell。</li>
<li>执行 docker diif 命令，可以看到容器相对于初始镜像做出的修改（ C:changed， A：added, D： deleted）。</li>
</ol>
<h2 id="容器的停止"><a href="#容器的停止" class="headerlink" title="容器的停止"></a>容器的停止</h2><pre><code>[root@localhost ~]# docker stop 1575c6863d8b 
1575c6863d8b
</code></pre><p>可以通过 docker stop 命令停止一个容器的运行。 </p>
<p>docker ps 命令只能看处于运行态的容器，如果想要查看所有的容器运行记录，需要通过 docker ps –a 命令。</p>
<pre><code>[root@localhost ~]# docker ps -a
CONTAINER ID        IMAGE               COMMAND                   CREATED             STATUS                        PORTS               NAMES
1575c6863d8b        busybox             &quot;sh&quot;                      13 minutes ago      Exited (137) 2 minutes ago                        keen_fermat
e52b8d7d0b15        busybox             &quot;echo &apos;Hello World\\!&apos;&quot;   2 days ago          Exited (0) 2 days ago                             dazzling_lalande
bb30ab886b21        hello-world         &quot;/hello&quot;                  2 days ago          Exited (0) 2 days ago                             sleepy_fermi
</code></pre><p>docker 还支持 docker pause,docker unpause 来暂停和恢复一个容器的执行,具体可以查看命令帮助。</p>
<h1 id="监控操作"><a href="#监控操作" class="headerlink" title="监控操作"></a>监控操作</h1><h2 id="docker-exec命令"><a href="#docker-exec命令" class="headerlink" title="docker exec命令"></a>docker exec命令</h2><p>docker exec命令的实质是进入到一个正在运行的容器中，并启动一个新的进程来监控容器，类似于 SSH 的功能。</p>
<pre><code>[root@localhost ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
1dfa0e308e9b        ubuntu              &quot;/bin/bash&quot;         4 hours ago         Up 4 hours                              determined_lalande
[root@localhost ~]# docker exec -it 1dfa0e308e9b bash
root@localhost:/# 
</code></pre><p>本例描述的步骤如下：</p>
<ol>
<li>使用 docker run 命令在后台启动一个 server 容器。</li>
<li>在本机 shell 中通过 docker ps 命令找到该容器对应的 ID。</li>
<li>通过 docker exec 命令登录到容器中，从命令行可以看出，已经进入了容器命令行的<br>界面。</li>
</ol>
<h2 id="docker-stats命令"><a href="#docker-stats命令" class="headerlink" title="docker stats命令"></a>docker stats命令</h2><p>通过 docker stats 命令，可以看到容器各项资源的使用情况。<br>    [root@localhost hello]# docker ps<br>    CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES<br>    25ce06e8b42c        busybox             “sh”                8 seconds ago       Up 7 seconds                            serene_payne<br>    [root@localhost hello]# docker stats 25ce06e8b42c<br>    CONTAINER           CPU %               MEM USAGE / LIMIT   MEM %               NET I/O             BLOCK I/O           PIDS<br>    25ce06e8b42c        0.00%               56KiB / 7.443GiB    0.00%               648B / 0B           0B / 0B             0</p>
<p>本例描述的步骤如下：</p>
<ol>
<li>在本机 shell 中通过 docker ps 命令找到需要监控的容器对应的 ID。</li>
<li>运行 docker stats 命令，可以查看正在运行的进程信息。 从输出可以看到容器占用的CPU、内存、硬盘、网络的资源使用情况</li>
</ol>
<h2 id="docker-logs命令"><a href="#docker-logs命令" class="headerlink" title="docker logs命令"></a>docker logs命令</h2><pre><code>[root@192 lxb]# docker logs 25ce06e8b42c
</code></pre><p>通过docker logs可以捕获到容器内部STDOUT和STD_ERR输出的信息，便于定位问题。<br>本例描述的步骤如下：</p>
<ol>
<li>在本机 shell 中通过 docker ps 命令找到需要监控的容器对应的 ID。</li>
<li>运行 docker logs 命令，可以查看容器内部的标准输出、标准错误信息。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/07/Docker私有仓库搭建/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LT">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/daniuli.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LT's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/07/Docker私有仓库搭建/" itemprop="url">Docker私有仓库搭建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-07T20:56:53+08:00">
                2017-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="私有仓库搭建"><a href="#私有仓库搭建" class="headerlink" title="私有仓库搭建"></a>私有仓库搭建</h1><h2 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h2><p>官方提供了Docker Hub网站来作为一个公开的集中仓库。然而，本地访问Docker Hub速度往往很慢，并且很多时候我们需要一个本地的私有仓库只供网内使用。</p>
<p>Docker仓库实际上提供两方面的功能，一个是镜像管理，一个是认证。前者主要由docker-registry项目来实现，通过http服务来上传下载；后者可以通过docker-index（闭源）项目或者利用现成认证方案（如nginx）实现http请求管理。</p>
<p>docker-registry既然也是软件应用，自然最简单的方法就是使用官方提供的已经部署好的镜像registry。官方文档中也给出了建议，直接运行sudo docker run -p 5000:5000 registry命令。这样确实能启动一个registry服务器，但是所有上传的镜像其实都是由docker容器管理，放在了/var/lib/docker/….某个目录下。而且一旦删除容器，镜像也会被删除。因此，我们需要想办法告诉docker容器镜像应该存放在哪里。registry镜像中启动后镜像默认位置是/tmp/registry，因此直接映射这个位置即可，比如到本机的/opt/data/registry目录下。</p>
<h2 id="不带安全认证的本地私有仓库"><a href="#不带安全认证的本地私有仓库" class="headerlink" title="不带安全认证的本地私有仓库"></a>不带安全认证的本地私有仓库</h2><ol>
<li><p>下载私有仓库镜像</p>
<pre><code>[root@localhost ~]# docker pull registry
Using default tag: latest
latest: Pulling from library/registry
90f4dba627d6: Pull complete 
3a754cdc94a5: Pull complete 
bf16d9b6d4c1: Pull complete 
7eea83c9b7bb: Pull complete 
23293c727551: Pull complete 
Digest: sha256:f5552e60ffd56fecbe2f04b61a3089a9cd755bd9352b6b5ab22cf2208af6a3a8
Status: Downloaded newer image for registry:latest
</code></pre></li>
<li><p>通过该镜像启动一个容器</p>
<pre><code>[root@localhost ~]# docker run -d -p 5000:5000 -v /opt/data/registry:/tmp/registry registry
0d042a2d7efe5f24becf343c26957b77c369054dd2e7c94d14d04f8a4df5715f
</code></pre><p>参数说明： </p>
<p>-d：表示容器后台运行</p>
<p>-p：端口映射</p>
<p>–restart=always：可以理解为开机启动。开机：就是启动docker客户端拉。</p>
<p>–name registry：给容器取一个名字，方便识别和记忆</p>
<p>-v:挂在本地文件到容器中。命令格式：hostdir:cdir[:rw|ro] 主机目录:容器目录[:读写权限]</p>
<p>具体参数可以参考<a href="https://docs.docker.com/registry/" target="_blank" rel="external">registry官方文档地址</a></p>
</li>
<li><p>客户端使用</p>
</li>
</ol>
<h2 id="搭建有安全认证的docker仓库私服"><a href="#搭建有安全认证的docker仓库私服" class="headerlink" title="搭建有安全认证的docker仓库私服"></a>搭建有安全认证的docker仓库私服</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/07/Docker镜像制作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LT">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/daniuli.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LT's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/07/Docker镜像制作/" itemprop="url">Docker镜像制作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-07T20:56:53+08:00">
                2017-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="镜像的制作"><a href="#镜像的制作" class="headerlink" title="镜像的制作"></a>镜像的制作</h1><p>镜像包的制作有两种方法，一种是在容器内部修改后，直接通过 docker commit 命令来生成新的镜像包，另一种是通过编写 Dockerfile 来描述镜像包的构建过程，并通过docker build 命令来生成，这里对这两种方法做一个介绍</p>
<h2 id="用commit命令制作镜像"><a href="#用commit命令制作镜像" class="headerlink" title="用commit命令制作镜像"></a>用commit命令制作镜像</h2><ol>
<li><p>运行ubuntu容器，并执行bash，-i 参数保持输入打开， -t 分配一个伪终端</p>
<pre><code>[root@localhost ~]# docker run -i -t ubuntu bash
root@3b102b069e4a:/# 
</code></pre></li>
</ol>
<ol>
<li><p>宿主机上运行拷贝宿主机jdk目录到容器。3b102b069e4a 为容器ID</p>
<pre><code>[root@localhost jvm]# docker cp java-1.8.0-openjdk-1.8.0.141-1.b16.el7_3.x86_64/ 3b102b069e4a:/usr/local/
</code></pre></li>
<li><p>配置环境变量</p>
<pre><code>root@3b102b069e4a:/usr/local# vi /etc/profile

export JAVA_HOME=/usr/local/java-1.8.0-openjdk-1.8.0.141-1.b16.el7_3.x86_64
export PATH=$JAVA_HOME/bin:$PATH
export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
</code></pre></li>
<li><p>退出docker容器        </p>
<pre><code>root@3b102b069e4a:/usr/local# exit
</code></pre></li>
<li><p>查看刚才运行的容器</p>
<pre><code>[root@localhost ~]# docker ps -a
CONTAINER ID        IMAGE               COMMAND                   CREATED             STATUS                        PORTS               NAMES
3b102b069e4a        ubuntu              &quot;bash&quot;                    24 minutes ago      Exited (130) 5 seconds ago                        confident_lumiere
</code></pre></li>
<li><p>查看不同，3b102b069e4a为容器ID。</p>
<pre><code>[root@localhost ~]# docker diff 3b102b069e4a
C /root
A /root/.bash_history
C /var
C /var/lib
C /var/lib/apt
C /var/lib/apt/lists
A /var/lib/apt/lists/lock
A /var/lib/apt/lists/partial
C /usr
C /usr/local
A /usr/local/java-1.8.0-openjdk-1.8.0.141-1.b16.el7_3.x86_64
A /usr/local/java-1.8.0-openjdk-1.8.0.141-1.b16.el7_3.x86_64/jre
A /usr/local/java-1.8.0-openjdk-1.8.0.141-1.b16.el7_3.x86_64/jre/bin
...
</code></pre></li>
<li><p>创建镜像</p>
<pre><code>[root@localhost hello]# docker commit -m &quot;add jdk8&quot; 3b102b069e4a
sha256:4f9bab60d59d134bd9b7d0b19f527b07d4f81428c221c2e623ebfbafde80fce0
</code></pre><p> 注：仓库名和TAG没有填写</p>
</li>
<li><p>查看是否生成成功</p>
</li>
</ol>
<pre><code>[root@localhost hello]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
&lt;none&gt;              &lt;none&gt;              4f9bab60d59d        9 seconds ago       250MB
ubuntu              latest              14f60031763d        2 weeks ago         120MB
</code></pre><h2 id="用Dockerfile制作镜像"><a href="#用Dockerfile制作镜像" class="headerlink" title="用Dockerfile制作镜像"></a>用Dockerfile制作镜像</h2><p>此处仅为示例，详细用法请参考<a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="external">官方文档</a>。</p>
<p>示例说明如下：</p>
<ol>
<li><p>新建一个名为 Dockerfile 的文件。</p>
</li>
<li><p>在 Docker 文件里描述镜像的构建过程。典型的流程为：</p>
</li>
</ol>
<ul>
<li>[1] 引入基础镜像，如本例中的 ubuntu:14.04。</li>
<li>[2] 在该基础镜像上安装一系列软件，如本例中通过 apt-get 命令来安装了 mysql 以及相关的组件。</li>
<li>[3] 对软件进行配置。如本例中配置了 mysql 的挂载目录、工作目录、对外暴露的端口号等等。</li>
<li>[4] 设置容器运行后要执行的命令，例如本例中，设置了当容器运行时，需要通过mysqld_safe 命令来启动 mysql 服务器（上述 FROM， RUN， VOLUME， EXPOSE， CMD 等命令都是 Dockerfile 文件的基本语法元素，可以查看具体<a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="external">官方文档</a>了解使用方式。）</li>
</ul>
<ol>
<li><p>通过 docker build 命令来制作镜像文件。 -t 选项为镜像取名， .则表示 Docker 文件在当前目录中。</p>
</li>
<li><p>通过 docker images 命令，可以查看新创建的镜像文件。</p>
</li>
<li><p>最后，通过 docker run 命令利用新建的镜像开启一个容器，从打印中可以看到 mysql服务已经生效了</p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/05/Docker环境构建/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LT">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/daniuli.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LT's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/05/Docker环境构建/" itemprop="url">Docker环境构建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-05T11:01:54+08:00">
                2017-08-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一-版本及系统要求"><a href="#一-版本及系统要求" class="headerlink" title="一. 版本及系统要求"></a>一. 版本及系统要求</h2><h3 id="1-Docker版本说明"><a href="#1-Docker版本说明" class="headerlink" title="1. Docker版本说明"></a>1. Docker版本说明</h3><p>2017/3/3，Docker官方发表了一篇博客，Docker版本从1.13.*直接跳入17.03，该版本的意思是17年3月。同时，还声明了Docker以后会以CE（Community Edition）和EE（Enterprise Edition）的形式发布。其中，CE版本每个月发布一次，也就是说，随后的版本就是17.03、17.04、17.05等，而EE的版本是没三个月发布一次，对应的就是17.03、17.06等。对于发布的每个EE版本，Docker官网都会提供一年的技术支持。</p>
<center>CE和EE在各发行版的支持情况<br><br>Platform| Docker EE | Docker CE<br>———|———-|———<br>Ubuntu | yes | yes<br>Debian |  | yes<br>Red Hat Enterprise Linux yes |     yes |<br>CentOS | yes | yes<br>Fedora | | yes<br>Oracle Linux | yes |<br>SUSE Linux Enterprise Server | yes |<br>Microsoft Windows Server 2016 | yes |<br>Microsoft Windows 10 | | yes<br>macOS | | yes<br>Microsoft Azure | yes | yes<br>Amazon Web Services | yes | yes<br></center>


<h3 id="2-对linux内核版本的要求"><a href="#2-对linux内核版本的要求" class="headerlink" title="2. 对linux内核版本的要求"></a>2. 对linux内核版本的要求</h3><p>docker对linux内核版本有要求，内核版本不能太低， 如果太低会导致docker的一些功能不能使用， docker官方文档要求至少3.8以上，建议3.10以上。</p>
<p>考虑到通用性，计划采用CentOS版本，目前Centos 7 使用的内核版本为3.10。</p>
<pre><code>注：中兴新支点的CGSL来源于开源社区，由开源社区的源代码构建，在提供CGSL版本的时候，参考了CentOS (对应于RHEL的开源版本)所用的内核版本号和相关软件包， 并根据实际需要选取了他们所用的补丁集(毕竟红帽所用的方案是业界公认比较出色的)。因此，CGSL与RHEL是高度兼容的。

CGSL V3 在今年生命周期已到最后阶段，后续不再发货，其内核版本为 2.6.18-164；
CGSL V4 内核版本为2.6.32，V4系列版本现已进入成熟期，稳定商用多年，建议在没特殊要求的情况下使用此版本。
CGSL V5 内核版本为3.10.0 , 此版本完美适配虚拟化，如环境需要用于虚拟化的场景，建议使用此版本。
</code></pre><h3 id="3-CentOS的安装"><a href="#3-CentOS的安装" class="headerlink" title="3. CentOS的安装"></a>3. CentOS的安装</h3><p>版本：CentOS-7-x86_64-DVD-1511.iso</p>
<p>内核：3.10.0-327.el7.x86_64</p>
<p>安装过程略</p>
<h3 id="4-构建本地CentOS的YUM源"><a href="#4-构建本地CentOS的YUM源" class="headerlink" title="4. 构建本地CentOS的YUM源"></a>4. 构建本地CentOS的YUM源</h3><p>基于光盘ISO文件进行挂载</p>
<pre><code>mount -t iso9660 /home/hello/CentOS-7-x86_64-DVD-1511.iso /mnt/cdrom/
</code></pre><p> 在/etc/yum.repos.d/下新建repo文件，内容如下：</p>
<pre><code>[local_server]
name=This is a local repo
baseurl=file:///mnt/cdrom
enabled=1
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7
</code></pre><p>然后执行</p>
<pre><code>yum clean
yum makecache
</code></pre><h3 id="5-Docker的安装"><a href="#5-Docker的安装" class="headerlink" title="5. Docker的安装"></a>5. Docker的安装</h3><p>受限公司的网络，采用官方文档中的如下方式进行离线安装：</p>
<h4 id="Install-from-a-package"><a href="#Install-from-a-package" class="headerlink" title="Install from a package"></a>Install from a package</h4><p>If you cannot use Docker’s repository to install Docker, you can download the .rpm file for your release and install it manually. You will need to download a new file each time you want to upgrade Docker.</p>
<h5 id="1-Go-to-https-download-docker-com-linux-centos-7-x86-64-stable-Packages-and-download-the-rpm-file-for-the-Docker-version-you-want-to-install"><a href="#1-Go-to-https-download-docker-com-linux-centos-7-x86-64-stable-Packages-and-download-the-rpm-file-for-the-Docker-version-you-want-to-install" class="headerlink" title="1. Go to https://download.docker.com/linux/centos/7/x86_64/stable/Packages/ and download the .rpm file for the Docker version you want to install."></a>1. Go to <a href="https://download.docker.com/linux/centos/7/x86_64/stable/Packages/" target="_blank" rel="external">https://download.docker.com/linux/centos/7/x86_64/stable/Packages/</a> and download the .rpm file for the Docker version you want to install.</h5><h5 id="2-Install-Docker-CE-changing-the-path-below-to-the-path-where-you-downloaded-the-Docker-package"><a href="#2-Install-Docker-CE-changing-the-path-below-to-the-path-where-you-downloaded-the-Docker-package" class="headerlink" title="2. Install Docker CE, changing the path below to the path where you downloaded the Docker package."></a>2. Install Docker CE, changing the path below to the path where you downloaded the Docker package.</h5><pre><code>$ sudo yum install /path/to/package.rpm
</code></pre><h3 id="6-Docker官方镜像加速"><a href="#6-Docker官方镜像加速" class="headerlink" title="6. Docker官方镜像加速"></a>6. Docker官方镜像加速</h3><h4 id="6-1-修改镜像源"><a href="#6-1-修改镜像源" class="headerlink" title="6.1 修改镜像源"></a>6.1 修改镜像源</h4><p>通过 Docker 官方镜像加速，中国区用户能够快速访问最流行的 Docker 镜像。该镜像托管于中国大陆，本地用户现在将会享受到更快的下载速度和更强的稳定性，从而能够更敏捷地开发和交付 Docker 化应用。</p>
<p>Docker 中国官方镜像加速可通过 registry.docker-cn.com 访问。该镜像库只包含流行的公有镜像。私有镜像仍需要从美国镜像库中拉取。</p>
<p>修改 /etc/docker/daemon.json 文件并添加上 registry-mirrors 键值，保存后重启docker以生效</p>
<pre><code>{
&quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]
}
</code></pre><h4 id="6-2-内网代理设置"><a href="#6-2-内网代理设置" class="headerlink" title="6.2 内网代理设置"></a>6.2 内网代理设置</h4><p>First, create a systemd drop-in directory for the docker service:</p>
<pre><code>mkdir /etc/systemd/system/docker.service.d
</code></pre><p>Now create a file called /etc/systemd/system/docker.service.d/http-proxy.conf that adds the HTTP_PROXY environment variable:</p>
<pre><code>[Service]
Environment=&quot;HTTP_PROXY=http://proxy.example.com:80/&quot;
</code></pre><p>If you have internal Docker registries that you need to contact without proxying you can specify them via the NO_PROXY environment variable:</p>
<pre><code>Environment=&quot;HTTP_PROXY=http://proxy.example.com:80/&quot;
Environment=&quot;NO_PROXY=localhost,127.0.0.0/8,docker-registry.somecorporation.com&quot;
</code></pre><p>Flush changes:</p>
<pre><code>$ sudo systemctl daemon-reload
</code></pre><p>Verify that the configuration has been loaded:</p>
<pre><code>$ sudo systemctl show docker --property Environment
Environment=HTTP_PROXY=http://proxy.example.com:80/
</code></pre><p>Restart Docker:</p>
<pre><code>$ sudo systemctl restart docker
</code></pre><h3 id="7-验证环境"><a href="#7-验证环境" class="headerlink" title="7. 验证环境"></a>7. 验证环境</h3><h4 id="7-1-从Docker仓库获取一个镜像"><a href="#7-1-从Docker仓库获取一个镜像" class="headerlink" title="7.1 从Docker仓库获取一个镜像"></a>7.1 从Docker仓库获取一个镜像</h4><pre><code>[root@localhost hello]# docker pull hello-world
Using default tag: latest
latest: Pulling from library/hello-world
b04784fba78d: Pull complete 
Digest: sha256:f3b3b28a45160805bb16542c9531888519430e9e6d6ffc09d72261b0d26ff74f
Status: Downloaded newer image for hello-world:latest
</code></pre><h4 id="7-2-查看本地镜像"><a href="#7-2-查看本地镜像" class="headerlink" title="7.2 查看本地镜像"></a>7.2 查看本地镜像</h4><pre><code>[root@localhost hello]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
hello-world         latest              1815c82652c0        7 weeks ago         1.84kB
</code></pre><ol>
<li>REPOSITORY：该字段包括两部分，第一部分是仓库名字（docker.io），第二部分是镜像包的名字。</li>
<li>TAG：用来表征镜像的版本号，默认情况下拖取最新版本（latest），也可以指定镜像的具体版本。</li>
<li>IMAGE_ID：一个哈希值，用来唯一标志一个镜像文件。</li>
<li>CREATED：镜像创建的时间。</li>
<li>VIRTUAL SIZE：镜像的大小。</li>
</ol>
<h4 id="7-3-利用镜像包启动一个容器"><a href="#7-3-利用镜像包启动一个容器" class="headerlink" title="7.3 利用镜像包启动一个容器"></a>7.3 利用镜像包启动一个容器</h4><pre><code>[root@localhost hello]# docker run hello-world

Hello from Docker!
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
1. The Docker client contacted the Docker daemon.
2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.
3. The Docker daemon created a new container from that image which runs the
    executable that produces the output you are currently reading.
4. The Docker daemon streamed that output to the Docker client, which sent it
    to your terminal.

To try something more ambitious, you can run an Ubuntu container with:
$ docker run -it ubuntu bash

Share images, automate workflows, and more with a free Docker ID:
https://cloud.docker.com/

For more examples and ideas, visit:
https://docs.docker.com/engine/userguide/
</code></pre><h4 id="8-小结"><a href="#8-小结" class="headerlink" title="8. 小结"></a>8. 小结</h4><p>目前公司访问外网，特别是在linux上直接访问外网，是相当的有问题。</p>
<p>后续考虑搭建内网私服，需要单独开一章节来进行说明。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/05/Docker简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LT">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/daniuli.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LT's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/05/Docker简介/" itemprop="url">Docker简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-05T10:56:15+08:00">
                2017-08-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、Docker简介"><a href="#一、Docker简介" class="headerlink" title="一、Docker简介"></a><strong>一、Docker简介</strong></h2><p>Docker是一个由GO语言开发的，基于LXCs(Linux containers)的高级容器引擎，实现了一种应用程序级别的隔离，源代码托管在Github上,遵从Apache2.0协议开源。</p>
<p>Container技术并非Docker的创新，很多云服务商都采用了类似这种轻量级的虚拟化技术，但Docker是第一个将这这种Container技术大规模开源并被社区广泛接受的。</p>
<p>Docker使用以下操作系统的功能来提高容器技术的效率：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/764980-37bfc1d698d4a95b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原理图"></p>
<blockquote>
<p>Namespace 充当隔离的第一级。确保一个容器中运行一个进程而且不能看到或影响容器外的其它进程。</p>
<p>Control Groups是LXC的重要组成部分，具有资源核算与限制的关键功能，实现了对资源的配额和度量。</p>
<p>UnionFS（文件系统）作为容器的构建块。为了支持Docker的轻量级以及速度快的特性，它创建了用户层。</p>
</blockquote>
<h2 id="二、Docker自身的组件与元素"><a href="#二、Docker自身的组件与元素" class="headerlink" title="二、Docker自身的组件与元素"></a><strong>二、Docker自身的组件与元素</strong></h2><center>图1.运行示意图</center>

<center><br><br><img src="https://docs.docker.com/engine/article-img/engine-components-flow.png" alt="Docker engine"><br><br></center>

<center><br>图2.组件架构图<br></center>

<center><br><br><img src="https://docs.docker.com/engine/article-img/architecture.svg" alt="Docker architecture"><br><br></center>

<p>几个概念：</p>
<h4 id="1-Docker-Client-amp-Docker-Daemon"><a href="#1-Docker-Client-amp-Docker-Daemon" class="headerlink" title="1. Docker Client &amp; Docker Daemon"></a>1. Docker Client &amp; Docker Daemon</h4><p>Docker使用客户端-服务器(client-server)架构模式。Docker客户端会与Docker守护进程进行通信。Docker守护进程会处理复杂繁重的任务，例如建立、运行、发布你的Docker容器。Docker客户端和守护进程可以运行在同一个系统上，当然你也可以使用Docker客户端去连接一个远程的Docker守护进程。Docker客户端和守护进程之间通过socket或者RESTful API进行通信。</p>
<h4 id="2-Docker镜像"><a href="#2-Docker镜像" class="headerlink" title="2. Docker镜像"></a>2. Docker镜像</h4><p>Docker 镜像是 Docker 容器运行时的只读模板，每一个镜像由一系列的层 (layers) 组成。</p>
<p>正因为有了这些层的存在，Docker 是如此的轻量。当你改变了一个 Docker 镜像，比如升级到某个程序到新的版本，一个新的层会被创建。</p>
<p>因此，不用替换整个原先的镜像或者重新建立(在使用虚拟机的时候你可能会这么做)，只是一个新的层被添加或升级了。不用重新发布整个镜像，只需要升级，层使得分发 Docker 镜像变得简单和快速。</p>
<h4 id="5-Docker容器"><a href="#5-Docker容器" class="headerlink" title="5. Docker容器"></a>5. Docker容器</h4><p>Docker 容器和文件夹很类似，一个Docker容器包含了所有的某个应用运行所需要的环境。每一个 Docker 容器都是从 Docker 镜像创建的。</p>
<p>Docker 容器可以运行、开始、停止、移动和删除。每一个 Docker 容器都是独立和安全的应用平台，Docker 容器是 Docker 的运行部分。</p>
<h4 id="4-Docker仓库"><a href="#4-Docker仓库" class="headerlink" title="4. Docker仓库"></a>4. Docker仓库</h4><p>类似于Github的一种代码仓库，同样，Docker 仓库也有公有和私有的概念。公有的 Docker 仓库名字是 Docker Hub。Docker Hub 提供了庞大的镜像集合供使用。这些镜像可以是自己创建，或者在别人的镜像基础上创建。Docker 仓库是 Docker 的分发部分。</p>
<h2 id="三、Docker的运行流程"><a href="#三、Docker的运行流程" class="headerlink" title="三、Docker的运行流程"></a><strong>三、Docker的运行流程</strong></h2><p>举例说明，执行如下命令：</p>
<pre><code>$ docker run -i -t ubuntu /bin/bash
</code></pre><p>docker client会启动，然后使用后面的run参数来通知docker daemon启动一个新容器。</p>
<p>这个简短的命令将会通知docker daemon以下信息：</p>
<p>1、容器所需的image在哪里，这里image名称是ubuntu，是一个base image。</p>
<p>2、当容器启动时，你想让容器初始化的动作，这里我们需要容器启动时自动切换到/bin/bash下面。</p>
<p>所以当我们敲下回车后，docker将会如何处理呢？</p>
<p>1、Pulls the ubuntu image</p>
<p> Docker检测image是否存在，如果本地不存在，则默认从Dock Hub下载。如果本地存在，则使用本地的image启动容器。</p>
<p>2、Creates a new container</p>
<p>Docker加载image，然后创建容器。</p>
<p>3、Allocates a filesystem and mounts a read-write layer</p>
<p>容器开始创建文件系统，并且在image上面添加可读可写的数据层。</p>
<p>4、Allocates a network / bridge interface</p>
<p>Docker开始创建网络接口，并且允许容器同主机进行关联。</p>
<p>5、Sets up an IP address</p>
<p>Docker从IP资源池中挑选一个分配给容器。</p>
<p>6、Executes a process that you specify</p>
<p>Docker开始执行指定的应用或者命令</p>
<p>7、Captures and provides application output</p>
<p>Docker将执行过程当中的输出或者错误信息返回给Client。让用户可以知道当前应用执行的情况。</p>
<h2 id="四、Docker的组网模式"><a href="#四、Docker的组网模式" class="headerlink" title="四、Docker的组网模式"></a><strong>四、Docker的组网模式</strong></h2><h3 id="1-host模式，使用–net-host指定"><a href="#1-host模式，使用–net-host指定" class="headerlink" title="1. host模式，使用–net=host指定"></a>1. host模式，使用–net=host指定</h3><p>Docker使用了Linux的Namespaces技术来进行资源隔离，如PID Namespace隔离进程，Mount Namespace隔离文件系统，Network Namespace隔离网络等。一个Network Namespace提供了一份独立的网络环境，包括网卡、路由、Iptable规则等都与其他的Network Namespace隔离。一个Docker容器一般会分配一个独立的Network Namespace。</p>
<p>如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。</p>
<p>但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p>
<h3 id="2-container模式，使用–net-container-NAME-or-ID指定"><a href="#2-container模式，使用–net-container-NAME-or-ID指定" class="headerlink" title="2. container模式，使用–net=container:NAME_or_ID指定"></a>2. container模式，使用–net=container:NAME_or_ID指定</h3><p>这个模式指定新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。</p>
<p>新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。</p>
<p>同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。</p>
<h3 id="3-none模式，使用–net-none指定"><a href="#3-none模式，使用–net-none指定" class="headerlink" title="3. none模式，使用–net=none指定"></a>3. none模式，使用–net=none指定</h3><p>在这种模式下，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。</p>
<h3 id="4-bridge模式，使用–net-bridge指定，默认设置"><a href="#4-bridge模式，使用–net-bridge指定，默认设置" class="headerlink" title="4. bridge模式，使用–net=bridge指定，默认设置"></a>4. bridge模式，使用–net=bridge指定，默认设置</h3><p>Docker默认的网络设置，此模式会为每一个容器分配Network Namespace、设置IP等，并将一个主机上的Docker容器连接到一个虚拟网桥(如下图中的docker0)上。</p>
<h4 id="4-1-Bridge模式下的拓扑"><a href="#4-1-Bridge模式下的拓扑" class="headerlink" title="4.1 Bridge模式下的拓扑"></a>4.1 Bridge模式下的拓扑</h4><p><img src="http://cdn.infoqstatic.com/statics_s1_20170523-0350/resource/articles/docker-network-and-pipework-open-source-explanation-practice/zh/resources/1419249139653.png" alt="单机环境下的网络拓扑"></p>
<h4 id="4-2-Bridge模式下容器的通信"><a href="#4-2-Bridge模式下容器的通信" class="headerlink" title="4.2 Bridge模式下容器的通信"></a>4.2 Bridge模式下容器的通信</h4><p>举一个例子说明一下。假设主机有一块网卡为eth0，IP地址为10.10.101.105/24，网关为10.10.101.254。从主机上一个IP为172.17.0.1/16的容器中ping百度（180.76.3.151）。IP包首先从容器发往自己的默认网关docker0，包到达docker0后，也就到达了主机上。然后会查询主机的路由表，发现包应该从主机的eth0发往主机的网关10.10.105.254/24。接着包会转发给eth0，并从eth0发出去（主机的ip_forward转发应该已经打开）。这时候，上面的Iptable规则就会起作用，对包做SNAT转换，将源地址换为eth0的地址。这样，在外界看来，这个包就是从10.10.101.105上发出来的，Docker容器对外是不可见的。</p>
<p>将容器的80端口映射到主机的80端口，对主机eth0收到的目的端口为80的tcp流量进行DNAT转换，将流量发往172.17.0.5:80，也就是我们上面创建的Docker容器。所以，外界只需访问10.10.101.105:80就可以访问到容器中得服务。（除此之外，我们还可以自定义Docker使用的IP地址、DNS等信息，甚至使用自己定义的网桥，但是其工作方式还是一样的）</p>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明:"></a><strong>说明:</strong></h4><p>Docker自身的网络功能比较简单，不能满足很多复杂的应用场景，有很多开源项目用来改善Docker的网络功能。如果应用组网场景不复杂，还是能够满足要求的。</p>
<h4 id="演进中的网络模型"><a href="#演进中的网络模型" class="headerlink" title="演进中的网络模型"></a>演进中的网络模型</h4><p><img src="http://upload-images.jianshu.io/upload_images/625411-4159f9f26e5075b3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网络模型"></p>
<p>Sandbox：对应一个容器中的网络环境，包括相应的网卡配置、路由表、DNS配置等。CNM很形象的将它表示为网络的『沙盒』，因为这样的网络环境是随着容器的创建而创建，又随着容器销毁而不复存在的；</p>
<p>Endpoint：实际上就是一个容器中的虚拟网卡，在容器中会显示为eth0、eth1依次类推；</p>
<p>Network：指的是一个能够相互通信的容器网络，加入了同一个网络的容器直接可以直接通过对方的名字相互连接。它的实体本质上是主机上的虚拟网卡或网桥。</p>
<h3 id="5-共享网络命名空间"><a href="#5-共享网络命名空间" class="headerlink" title="5. 共享网络命名空间"></a>5. 共享网络命名空间</h3><p><img src="http://images2015.cnblogs.com/blog/907596/201705/907596-20170517110100869-2022531474.jpg" alt="共享网络"></p>
<p>当容器共享其他容器的网络命名空间，则在这两个容器之间不存在网络隔离，而她们又与宿主机以及除此之外其他的容器存在网络隔离</p>
<p>在这种模式下的容器可以通过localhost来同一网络命名空间下的其他容器，传输效率较高。而且这种模式还节约了一定数量的网络资源，但它并没有改变容器与外界通信的方式。</p>
<p>在一些特殊的场景中非常有用，例如，kubernetes的pod，kubernetes为pod创建一个基础设施容器，同一pod下的其他容器都以其他容器模式共享这个基础设施容器的网络命名空间，相互之间以localhost访问，构成一个统一的整体。</p>
<h2 id="五、Docker运行时资源限制"><a href="#五、Docker运行时资源限制" class="headerlink" title="五、Docker运行时资源限制"></a><strong>五、Docker运行时资源限制</strong></h2><p>Docker基于Linux内核提供的cgroups功能，可以限制容器在运行时使用到的资源，比如内存、CPU、块I/O、网络等。</p>
<h3 id="1-内存限制"><a href="#1-内存限制" class="headerlink" title="1. 内存限制"></a>1. 内存限制</h3><p>docker 提供的内存限制功能有以下几点：</p>
<ul>
<li>容器能使用的内存和交换分区大小。</li>
<li>容器的核心内存大小。</li>
<li>容器虚拟内存的交换行为。</li>
<li>容器内存的软性限制。</li>
<li>是否杀死占用过多内存的容器。</li>
<li>容器被杀死的优先级</li>
</ul>
<p>一般情况下，达到内存限制的容器过段时间后就会被系统杀死。</p>
<h3 id="2-CPU限制"><a href="#2-CPU限制" class="headerlink" title="2.CPU限制"></a>2.CPU限制</h3><p>Docker的资源限制和隔离完全基于linux cgroups。对CPU资源的限制方式也和cgroups相同。</p>
<p>Docker提供的CPU资源限制选项可以在多核系统上限制容器能利用哪些CPU，而对容器最多能使用的 CPU 时间有两种限制方式：</p>
<ul>
<li>有多个 CPU 密集型的容器竞争 CPU 时，设置各个容器能使用的 CPU 时间相对比例。</li>
<li>以绝对的方式设置容器在每个调度周期内最多能使用的 CPU 时间。</li>
</ul>
<h3 id="3-磁盘IO配额控制"><a href="#3-磁盘IO配额控制" class="headerlink" title="3.磁盘IO配额控制"></a>3.磁盘IO配额控制</h3><p>相对于CPU和内存的配额控制，docker对磁盘IO的控制相对不成熟，大多数都必须在有宿主机设备的情况下使用。主要包括以下参数：</p>
<ul>
<li>–device-read-bps：限制此设备上的读速度（bytes per second），单位可以是kb、mb或者gb。</li>
<li>–device-read-iops：通过每秒读IO次数来限制指定设备的读速度。</li>
<li>–device-write-bps ：限制此设备上的写速度（bytes per second），单位可以是kb、mb或者gb。</li>
<li>–device-write-iops：通过每秒写IO次数来限制指定设备的写速度。</li>
<li>–blkio-weight：容器默认磁盘IO的加权值，有效值范围为10-100。</li>
<li>–blkio-weight-device： 针对特定设备的IO加权控制。其格式为DEVICE_NAME:WEIGHT</li>
</ul>
<h3 id="4-磁盘空间限制"><a href="#4-磁盘空间限制" class="headerlink" title="4.磁盘空间限制"></a>4.磁盘空间限制</h3><p>在docker使用devicemapper作为存储驱动时，默认每个容器和镜像的最大大小为10G。如果需要调整，可以在daemon启动参数中，使用dm.basesize来指定，但需要注意的是，修改这个值，不仅仅需要重启docker daemon服务，还会导致宿主机上的所有本地镜像和容器都被清理掉。</p>
<p>使用aufs或者overlay等其他存储驱动时，没有这个限制。</p>
<h2 id="六、与虚拟机的对比"><a href="#六、与虚拟机的对比" class="headerlink" title="六、与虚拟机的对比"></a><strong>六、与虚拟机的对比</strong></h2><h3 id="1-实现原理"><a href="#1-实现原理" class="headerlink" title="1. 实现原理"></a>1. 实现原理</h3><p><img src="http://7u2qr4.com1.z0.glb.clouddn.com/blog_%E5%9B%BE%E7%89%871.png" alt="对比"><br><img src="http://7u2qr4.com1.z0.glb.clouddn.com/blog_%E5%9B%BE%E7%89%872.png" alt="对比"></p>
<p>通过docker和虚拟机实现原理的比较，我们大致可以得出一些结论： </p>
<blockquote>
<ol>
<li><p>docker有着比虚拟机更少的抽象层。由于docker不需要Hypervisor实现硬件资源虚拟化，运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有优势，具体的效率对比在下几个小节里给出。在IO设备虚拟化上，docker的镜像管理有多种方案，比如利用Aufs文件系统或者Device Mapper实现docker的文件管理，各种实现方案的效率略有不同。 </p>
</li>
<li><p>docker利用的是宿主机的内核，而不需要Guest OS。因此，当新建一个容器时，docker不需要和虚拟机一样重新加载一个操作系统内核。我们知道，引导、加载操作系统内核是一个比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载Guest OS，这个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统，则省略了这个过程，因此新建一个docker容器只需要几秒钟。另外，现代操作系统是复杂的系统，在一台物理机上新增加一个操作系统的资源开销是比较大的，因此，docker对比虚拟机在资源消耗上也占有比较大的优势。事实上，在一台物理机上我们可以很容易建立成百上千的容器，而只能建立几个虚拟机。</p>
</li>
</ol>
</blockquote>
<h3 id="2-计算效率"><a href="#2-计算效率" class="headerlink" title="2. 计算效率"></a>2. 计算效率</h3><p><img src="http://7u2qr4.com1.z0.glb.clouddn.com/blog_%E5%9B%BE%E7%89%873.png" alt="计算效率"></p>
<p>可见docker相对于物理机其计算能力几乎没有损耗，而虚拟机对比物理机则有着非常明显的损耗。虚拟机的计算能力损耗在50%左右。 </p>
<p>为什么会有这么大的性能损耗呢？</p>
<blockquote>
<p>一方面是因为虚拟机增加了一层虚拟硬件层，运行在虚拟机上的应用程序在进行数值计算时是运行在Hypervisor虚拟的CPU上的</p>
<p>另外一方面是由于计算程序本身的特性导致的差异。虚拟机虚拟的cpu架构不同于实际cpu架构，数值计算程序一般针对特定的cpu架构有一定的优化措施，虚拟化使这些措施作废，甚至起到反效果。</p>
</blockquote>
<h3 id="3-内存访问效率"><a href="#3-内存访问效率" class="headerlink" title="3. 内存访问效率"></a>3. 内存访问效率</h3><p><img src="http://7u2qr4.com1.z0.glb.clouddn.com/blog_TimLine%E6%88%AA%E5%9B%BE20150226143346.png" alt="内存访问"></p>
<p>内存访问效率的比较相对比较复杂一点，主要是内存访问有多种场景： </p>
<blockquote>
<p>（1）大批量的，连续地址块的内存数据读写。这种测试环境下得到的性能数据是内存带宽，性能瓶颈主要在内存芯片的性能上； </p>
<p>（2）随机内存访问性能。这种测试环境下的性能数据主要与内存带宽、cache的命中率和虚拟地址与物理地址转换的效率等因素有关。 </p>
</blockquote>
<p>在应用程序内存访问上，虚拟机的应用程序要进行2次的虚拟内存到物理内存的映射，读写内存的代价比docker的应用程序高。 </p>
<h3 id="4-启动时间及资源耗费"><a href="#4-启动时间及资源耗费" class="headerlink" title="4. 启动时间及资源耗费"></a>4. 启动时间及资源耗费</h3><p>无论从启动时间还是从启动资源耗费角度来说。docker直接利用宿主机的系统内核，避免了虚拟机启动时所需的系统引导时间和操作系统运行的资源消耗。利用docker能在几秒钟之内启动大量的容器，这是虚拟机无法办到的。快速启动、低系统资源消耗的优点使docker在弹性云平台和自动运维系统方面有着很好的应用前景。</p>
<h3 id="5-Docker的劣势"><a href="#5-Docker的劣势" class="headerlink" title="5. Docker的劣势"></a>5. Docker的劣势</h3><ol>
<li><p>资源隔离方面不如虚拟机，docker是利用cgroup实现资源限制的，只能限制资源消耗的最大值，而不能隔绝其他程序占用自己的资源。 </p>
</li>
<li><p>安全性问题。docker目前并不能分辨具体执行指令的用户，只要一个用户拥有执行docker的权限，那么他就可以对docker的容器进行所有操作，不管该容器是否是由该用户创建。比如A和B都拥有执行docker的权限，由于docker的server端并不会具体判断docker cline是由哪个用户发起的，A可以删除B创建的容器，存在一定的安全风险。 </p>
</li>
<li><p>docker目前还在版本的快速更新中，细节功能调整比较大。一些核心模块依赖于高版本内核，存在版本兼容问题</p>
</li>
<li><p>真实投入生产，还需要多种开源组件和技术的支持，如kubernetes管理容器、etcd管理存储、应用打包技术dockerfile、容器间的网络管理flannel、私有仓库的构建、持续集成jenkins的结合、监控docker的工具等等。</p>
</li>
</ol>
<h2 id="七、Docker的应用场景"><a href="#七、Docker的应用场景" class="headerlink" title="七、Docker的应用场景"></a><strong>七、Docker的应用场景</strong></h2><h3 id="1-简化配置"><a href="#1-简化配置" class="headerlink" title="1. 简化配置"></a>1. 简化配置</h3><p>这是Docker公司宣传的Docker的主要使用场景。虚拟机的最大好处是能在你的硬件设施上运行各种配置不一样的平台（软件、系统），Docker在降低额外开销的情况下提供了同样的功能。它能让你将运行环境和配置放在代码中然后部署，同一个Docker的配置可以在不同的环境中使用，这样就降低了硬件要求和应用环境之间耦合度。</p>
<h3 id="2-代码流水线（Code-Pipeline）"><a href="#2-代码流水线（Code-Pipeline）" class="headerlink" title="2. 代码流水线（Code Pipeline）"></a>2. 代码流水线（Code Pipeline）</h3><p>管理前一个场景对于管理代码的流水线起到了很大的帮助。代码从开发者的机器到最终在生产环境上的部署，需要经过很多的中间环境。而每一个中间环境都有自己微小的差别，Docker给应用提供了一个从开发到上线均一致的环境，让代码的流水线变得简单不少。</p>
<h3 id="3-提高开发效率"><a href="#3-提高开发效率" class="headerlink" title="3. 提高开发效率"></a>3. 提高开发效率</h3><p>不同的开发环境中，我们都想把两件事做好。一是我们想让开发环境尽量贴近生产环境，二是我们想快速搭建开发环境。理想状态中，要达到第一个目标，我们需要将每一个服务都跑在独立的虚拟机中以便监控生产环境中服务的运行状态。然而，我们却不想每次都需要网络连接，每次重新编译的时候远程连接上去特别麻烦。这就是Docker做的特别好的地方，开发环境的机器通常内存比较小，之前使用虚拟的时候，我们经常需要为开发环境的机器加内存，而现在Docker可以轻易的让几十个服务在Docker中跑起来。</p>
<p>另外一个场景就是，比如要设置mips的编译环境，而宿主机是debian.有些优秀的工具只存在于gentoo平台，而gentoo又不好安装，我们使用docker只要从docker hub上面pull下镜像，就可以完美使用，这使得开发人员效率最大化。</p>
<h3 id="4-隔离应用"><a href="#4-隔离应用" class="headerlink" title="4. 隔离应用"></a>4. 隔离应用</h3><p>有很多种原因会让你选择在一个机器上运行不同的应用，比如之前提到的提高开发效率的场景等。我们经常需要考虑两点，一是因为要降低成本而进行服务器整合，二是将一个整体式的应用拆分成松耦合的单个服务（即微服务架构）。</p>
<p>在权衡资源隔离(比如限制应用最大内存使用量，或者资源加载隔离，彼此资源占用互相不影响等)和低消耗(虚拟化本身带来的损耗需要尽量的低)上，Docker很好的权衡了两者，即拥有不错的资源隔离能力，又有很低的虚拟化开销。</p>
<h3 id="5-整合服务器"><a href="#5-整合服务器" class="headerlink" title="5. 整合服务器"></a>5. 整合服务器</h3><p>正如通过虚拟机来整合多个应用，Docker隔离应用的能力使得Docker可以整合多个服务器以降低成本。由于没有多个操作系统的内存占用，以及能在多个实例之间共享没有使用的内存，Docker可以比虚拟机提供更好的服务器整合解决方案。</p>
<h3 id="6-调试能力"><a href="#6-调试能力" class="headerlink" title="6. 调试能力"></a>6. 调试能力</h3><p>Docker提供了很多的工具，这些工具不一定只是针对容器，但是却适用于容器。它们提供了很多的功能，包括可以为容器设置检查点、设置版本和查看两个容器之间的差别，这些特性可以帮助调试Bug。你可以在《Docker拯救世界》的文章中找到这一点的例证。</p>
<h3 id="7-多租户环境"><a href="#7-多租户环境" class="headerlink" title="7. 多租户环境"></a>7. 多租户环境</h3><p>另外一个Docker有意思的使用场景是在多租户的应用中，它可以避免关键应用的重写。我们一个特别的关于这个场景的例子是为IoT（译者注：物联网）的应用开发一个快速、易用的多租户环境。这种多租户的基本代码非常复杂，很难处理，重新规划这样一个应用不但消耗时间，也浪费金钱。使用Docker，可以为每一个租户的应用层的多个实例创建隔离的环境，这不仅简单而且成本低廉，当然这一切得益于Docker环境的启动速度和其高效的diff命令。你可以在这里了解关于此场景的更多信息。</p>
<h3 id="8-快速部署"><a href="#8-快速部署" class="headerlink" title="8. 快速部署"></a>8. 快速部署</h3><p>在虚拟机之前，引入新的硬件资源需要消耗几天的时间。Docker的虚拟化技术将这个时间降到了几分钟，Docker只是创建一个容器进程而无需启动操作系统，这个过程只需要秒级的时间。这正是Google和Facebook都看重的特性。你可以在数据中心创建销毁资源而无需担心重新启动带来的开销。通常数据中心的资源利用率只有30%，通过使用Docker并进行有效的资源分配可以提高资源的利用率。</p>
<h3 id="9-从轻量级工具、持续集成演进到微服务架构"><a href="#9-从轻量级工具、持续集成演进到微服务架构" class="headerlink" title="9. 从轻量级工具、持续集成演进到微服务架构"></a>9. 从轻量级工具、持续集成演进到微服务架构</h3><p>早在14年国内有一些公司，开始尝试docker，当时毕竟docker是一个新事物，很多新特性方面的优点，并没有被大大的利用起来，这个也可以理解。那时docker对一些企业的价值在于计算的轻量级，也就是对于一些计算型的任务，通过docker的形式来分发，部署快，隔离性好，这样的任务包括：消息传递，图像处理等。</p>
<p>14下半年到15年初，docker的价值被更大化，应用的运行，服务的托管，外界的接受度也变高，国内也出现了一些startup公司，比如DaoCloud,灵雀云等。但这些仅仅是这些公司的第一步，后续紧跟的更多的是基于代码与镜像之间的CI/CD,缩减开发测试发布的流程，这方面的实践逐渐成熟。</p>
<p>微服务架构的兴起。微服务会对现阶段的软件架构有一些冲击，同样也是软件系统设计方法论的内容。这些方面国外讨论的要多一些，相信这一点也会近年来多家公司发力的地方。</p>
<h2 id="八、我们的需求及考虑"><a href="#八、我们的需求及考虑" class="headerlink" title="八、我们的需求及考虑"></a><strong>八、我们的需求及考虑</strong></h2><h3 id="1-需求场景"><a href="#1-需求场景" class="headerlink" title="1. 需求场景"></a>1. 需求场景</h3><blockquote>
<ul>
<li><p>与硬件的解耦</p>
</li>
<li><p>硬件资源的最大化利用、应用与应用之间的安全隔离</p>
</li>
<li><p>开发与测试、外场环境的一致性</p>
</li>
<li><p>版本的快速分发和部署</p>
</li>
<li><p>微服务的引入</p>
</li>
</ul>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/28/Summer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LT">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/daniuli.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LT's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/28/Summer/" itemprop="url">Summer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-28T00:03:29+08:00">
                2017-07-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/daniuli.jpg"
               alt="LT" />
          <p class="site-author-name" itemprop="name">LT</p>
           
              <p class="site-description motion-element" itemprop="description">Just some notes.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LT</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>

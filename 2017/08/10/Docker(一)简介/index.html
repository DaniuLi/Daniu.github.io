<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Docker," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="Docker简介Docker是一个由GO语言开发的，基于LXCs(Linux containers)的高级容器引擎，实现了一种应用程序级别的隔离，源代码托管在Github上,遵从Apache2.0协议开源。 Container技术并非Docker的创新，很多云服务商都采用了类似这种轻量级的虚拟化技术，但Docker是第一个将这这种Container技术大规模开源并被社区广泛接受的。 Docker使">
<meta name="keywords" content="Docker">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker(一)简介">
<meta property="og:url" content="http://yoursite.com/2017/08/10/Docker(一)简介/index.html">
<meta property="og:site_name" content="LT&#39;s Notes">
<meta property="og:description" content="Docker简介Docker是一个由GO语言开发的，基于LXCs(Linux containers)的高级容器引擎，实现了一种应用程序级别的隔离，源代码托管在Github上,遵从Apache2.0协议开源。 Container技术并非Docker的创新，很多云服务商都采用了类似这种轻量级的虚拟化技术，但Docker是第一个将这这种Container技术大规模开源并被社区广泛接受的。 Docker使">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/764980-37bfc1d698d4a95b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://docs.docker.com/engine/article-img/engine-components-flow.png">
<meta property="og:image" content="https://docs.docker.com/engine/article-img/architecture.svg">
<meta property="og:image" content="http://cdn.infoqstatic.com/statics_s1_20170523-0350/resource/articles/docker-network-and-pipework-open-source-explanation-practice/zh/resources/1419249139653.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/907596/201705/907596-20170517110100869-2022531474.jpg">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/625411-4159f9f26e5075b3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://7u2qr4.com1.z0.glb.clouddn.com/blog_%E5%9B%BE%E7%89%871.png">
<meta property="og:image" content="http://7u2qr4.com1.z0.glb.clouddn.com/blog_%E5%9B%BE%E7%89%872.png">
<meta property="og:image" content="http://7u2qr4.com1.z0.glb.clouddn.com/blog_%E5%9B%BE%E7%89%873.png">
<meta property="og:image" content="http://7u2qr4.com1.z0.glb.clouddn.com/blog_TimLine%E6%88%AA%E5%9B%BE20150226143346.png">
<meta property="og:updated_time" content="2017-08-10T14:30:37.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Docker(一)简介">
<meta name="twitter:description" content="Docker简介Docker是一个由GO语言开发的，基于LXCs(Linux containers)的高级容器引擎，实现了一种应用程序级别的隔离，源代码托管在Github上,遵从Apache2.0协议开源。 Container技术并非Docker的创新，很多云服务商都采用了类似这种轻量级的虚拟化技术，但Docker是第一个将这这种Container技术大规模开源并被社区广泛接受的。 Docker使">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/764980-37bfc1d698d4a95b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/08/10/Docker(一)简介/"/>





  <title>Docker(一)简介 | LT's Notes</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LT's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">LT's Notes</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/10/Docker(一)简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LT">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/daniuli.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LT's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Docker(一)简介</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-10T22:30:37+08:00">
                2017-08-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a><strong>Docker简介</strong></h1><p>Docker是一个由GO语言开发的，基于LXCs(Linux containers)的高级容器引擎，实现了一种应用程序级别的隔离，源代码托管在Github上,遵从Apache2.0协议开源。</p>
<p>Container技术并非Docker的创新，很多云服务商都采用了类似这种轻量级的虚拟化技术，但Docker是第一个将这这种Container技术大规模开源并被社区广泛接受的。</p>
<p>Docker使用以下操作系统的功能来提高容器技术的效率：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/764980-37bfc1d698d4a95b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原理图"></p>
<blockquote>
<p>Namespace 充当隔离的第一级。确保一个容器中运行一个进程而且不能看到或影响容器外的其它进程。</p>
<p>Control Groups是LXC的重要组成部分，具有资源核算与限制的关键功能，实现了对资源的配额和度量。</p>
<p>UnionFS（文件系统）作为容器的构建块。为了支持Docker的轻量级以及速度快的特性，它创建了用户层。</p>
</blockquote>
<a id="more"></a>
<h1 id="Docker自身的组件与元素"><a href="#Docker自身的组件与元素" class="headerlink" title="Docker自身的组件与元素"></a><strong>Docker自身的组件与元素</strong></h1><center>图1.运行示意图</center>

<center><br><br><img src="https://docs.docker.com/engine/article-img/engine-components-flow.png" alt="Docker engine"><br><br></center>

<center><br>图2.组件架构图<br></center>

<center><br><br><img src="https://docs.docker.com/engine/article-img/architecture.svg" alt="Docker architecture"><br><br></center>

<p>几个概念：</p>
<h2 id="1-Docker-Client-amp-Docker-Daemon"><a href="#1-Docker-Client-amp-Docker-Daemon" class="headerlink" title="1. Docker Client &amp; Docker Daemon"></a>1. Docker Client &amp; Docker Daemon</h2><p>Docker使用客户端-服务器(client-server)架构模式。Docker客户端会与Docker守护进程进行通信。Docker守护进程会处理复杂繁重的任务，例如建立、运行、发布你的Docker容器。Docker客户端和守护进程可以运行在同一个系统上，当然你也可以使用Docker客户端去连接一个远程的Docker守护进程。Docker客户端和守护进程之间通过socket或者RESTful API进行通信。</p>
<h2 id="2-Docker镜像"><a href="#2-Docker镜像" class="headerlink" title="2. Docker镜像"></a>2. Docker镜像</h2><p>Docker 镜像是 Docker 容器运行时的只读模板，每一个镜像由一系列的层 (layers) 组成。</p>
<p>正因为有了这些层的存在，Docker 是如此的轻量。当你改变了一个 Docker 镜像，比如升级到某个程序到新的版本，一个新的层会被创建。</p>
<p>因此，不用替换整个原先的镜像或者重新建立(在使用虚拟机的时候你可能会这么做)，只是一个新的层被添加或升级了。不用重新发布整个镜像，只需要升级，层使得分发 Docker 镜像变得简单和快速。</p>
<h2 id="5-Docker容器"><a href="#5-Docker容器" class="headerlink" title="5. Docker容器"></a>5. Docker容器</h2><p>Docker 容器和文件夹很类似，一个Docker容器包含了所有的某个应用运行所需要的环境。每一个 Docker 容器都是从 Docker 镜像创建的。</p>
<p>Docker 容器可以运行、开始、停止、移动和删除。每一个 Docker 容器都是独立和安全的应用平台，Docker 容器是 Docker 的运行部分。</p>
<h2 id="6-Docker仓库"><a href="#6-Docker仓库" class="headerlink" title="6. Docker仓库"></a>6. Docker仓库</h2><p>类似于Github的一种代码仓库，同样，Docker 仓库也有公有和私有的概念。公有的 Docker 仓库名字是 Docker Hub。Docker Hub 提供了庞大的镜像集合供使用。这些镜像可以是自己创建，或者在别人的镜像基础上创建。Docker 仓库是 Docker 的分发部分。</p>
<h1 id="Docker的运行流程"><a href="#Docker的运行流程" class="headerlink" title="Docker的运行流程"></a><strong>Docker的运行流程</strong></h1><p>举例说明，执行如下命令：</p>
<pre><code>$ docker run -i -t ubuntu /bin/bash
</code></pre><p>docker client会启动，然后使用后面的run参数来通知docker daemon启动一个新容器。</p>
<p>这个简短的命令将会通知docker daemon以下信息：</p>
<ol>
<li><p>容器所需的image在哪里，这里image名称是ubuntu，是一个base image。</p>
</li>
<li><p>当容器启动时，你想让容器初始化的动作，这里我们需要容器启动时自动切换到/bin/bash下面。</p>
</li>
</ol>
<p>所以当我们敲下回车后，docker将会如何处理呢？</p>
<ol>
<li><p>Pulls the ubuntu image</p>
<p> Docker检测image是否存在，如果本地不存在，则默认从Dock Hub下载。如果本地存在，则使用本地的image启动容器。</p>
</li>
<li><p>Creates a new container</p>
<p> Docker加载image，然后创建容器。</p>
</li>
<li><p>Allocates a filesystem and mounts a read-write layer</p>
<p> 容器开始创建文件系统，并且在image上面添加可读可写的数据层。</p>
</li>
<li><p>Allocates a network / bridge interface</p>
<p> Docker开始创建网络接口，并且允许容器同主机进行关联。</p>
</li>
<li><p>Sets up an IP address</p>
<p> Docker从IP资源池中挑选一个分配给容器。</p>
</li>
<li><p>Executes a process that you specify</p>
<p> Docker开始执行指定的应用或者命令</p>
</li>
<li><p>Captures and provides application output</p>
<p> Docker将执行过程当中的输出或者错误信息返回给Client。让用户可以知道当前应用执行的情况。</p>
</li>
</ol>
<h1 id="Docker的组网"><a href="#Docker的组网" class="headerlink" title="Docker的组网"></a><strong>Docker的组网</strong></h1><ol>
<li><p>host模式，使用–net=host指定</p>
<p> Docker使用了Linux的Namespaces技术来进行资源隔离，如PID Namespace隔离进程，Mount Namespace隔离文件系统，Network Namespace隔离网络等。一个Network Namespace提供了一份独立的网络环境，包括网卡、路由、Iptable规则等都与其他的Network Namespace隔离。一个Docker容器一般会分配一个独立的Network Namespace。</p>
<p> 如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。</p>
<p> 但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p>
</li>
<li><p>container模式，使用–net=container:NAME_or_ID指定</p>
<p> 这个模式指定新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。</p>
<p> 新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。</p>
<p> 同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。</p>
</li>
<li><p>none模式，使用–net=none指定</p>
<p> 在这种模式下，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。</p>
</li>
<li><p>bridge模式，使用–net=bridge指定，默认设置</p>
<p> Docker默认的网络设置，此模式会为每一个容器分配Network Namespace、设置IP等，并将一个主机上的Docker容器连接到一个虚拟网桥(如下图中的docker0)上。</p>
<p> (1). Bridge模式下的拓扑</p>
<p> <img src="http://cdn.infoqstatic.com/statics_s1_20170523-0350/resource/articles/docker-network-and-pipework-open-source-explanation-practice/zh/resources/1419249139653.png" alt="单机环境下的网络拓扑"></p>
<p> (2). Bridge模式下容器的通信</p>
<p> 举一个例子说明一下。假设主机有一块网卡为eth0，IP地址为10.10.101.105/24，网关为10.10.101.254。从主机上一个IP为172.17.0.1/16的容器中ping百度（180.76.3.151）。IP包首先从容器发往自己的默认网关docker0，包到达docker0后，也就到达了主机上。然后会查询主机的路由表，发现包应该从主机的eth0发往主机的网关10.10.105.254/24。接着包会转发给eth0，并从eth0发出去（主机的ip_forward转发应该已经打开）。这时候，上面的Iptable规则就会起作用，对包做SNAT转换，将源地址换为eth0的地址。这样，在外界看来，这个包就是从10.10.101.105上发出来的，Docker容器对外是不可见的。</p>
<p> 将容器的80端口映射到主机的80端口，对主机eth0收到的目的端口为80的tcp流量进行DNAT转换，将流量发往172.17.0.5:80，也就是我们上面创建的Docker容器。所以，外界只需访问10.10.101.105:80就可以访问到容器中得服务。（除此之外，我们还可以自定义Docker使用的IP地址、DNS等信息，甚至使用自己定义的网桥，但是其工作方式还是一样的）</p>
</li>
<li><p>共享网络命名空间</p>
<p> <img src="http://images2015.cnblogs.com/blog/907596/201705/907596-20170517110100869-2022531474.jpg" alt="共享网络"></p>
<p> 当容器共享其他容器的网络命名空间，则在这两个容器之间不存在网络隔离，而她们又与宿主机以及除此之外其他的容器存在网络隔离</p>
<p> 在这种模式下的容器可以通过localhost来同一网络命名空间下的其他容器，传输效率较高。而且这种模式还节约了一定数量的网络资源，但它并没有改变容器与外界通信的方式。</p>
<p> 在一些特殊的场景中非常有用，例如，kubernetes的pod，kubernetes为pod创建一个基础设施容器，同一pod下的其他容器都以其他容器模式共享这个基础设施容器的网络命名空间，相互之间以localhost访问，构成一个统一的整体。</p>
</li>
<li><p>演进中的网络模型</p>
<p> Docker自身的网络功能比较简单，不能满足很多复杂的应用场景，有很多开源项目用来改善Docker的网络功能。如果应用组网场景不复杂，还是能够满足要求的。</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/625411-4159f9f26e5075b3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网络模型"></p>
<p> Sandbox：对应一个容器中的网络环境，包括相应的网卡配置、路由表、DNS配置等。CNM很形象的将它表示为网络的『沙盒』，因为这样的网络环境是随着容器的创建而创建，又随着容器销毁而不复存在的；</p>
<p> Endpoint：实际上就是一个容器中的虚拟网卡，在容器中会显示为eth0、eth1依次类推；</p>
<p> Network：指的是一个能够相互通信的容器网络，加入了同一个网络的容器直接可以直接通过对方的名字相互连接。它的实体本质上是主机上的虚拟网卡或网桥。</p>
</li>
</ol>
<h1 id="Docker运行时资源限制"><a href="#Docker运行时资源限制" class="headerlink" title="Docker运行时资源限制"></a><strong>Docker运行时资源限制</strong></h1><p>Docker基于Linux内核提供的cgroups功能，可以限制容器在运行时使用到的资源，比如内存、CPU、块I/O、网络等。</p>
<h2 id="内存限制"><a href="#内存限制" class="headerlink" title="内存限制"></a>内存限制</h2><p>docker 提供的内存限制功能有以下几点：</p>
<ul>
<li>容器能使用的内存和交换分区大小。</li>
<li>容器的核心内存大小。</li>
<li>容器虚拟内存的交换行为。</li>
<li>容器内存的软性限制。</li>
<li>是否杀死占用过多内存的容器。</li>
<li>容器被杀死的优先级</li>
</ul>
<p>一般情况下，达到内存限制的容器过段时间后就会被系统杀死。</p>
<h2 id="CPU限制"><a href="#CPU限制" class="headerlink" title="CPU限制"></a>CPU限制</h2><p>Docker的资源限制和隔离完全基于linux cgroups。对CPU资源的限制方式也和cgroups相同。</p>
<p>Docker提供的CPU资源限制选项可以在多核系统上限制容器能利用哪些CPU，而对容器最多能使用的 CPU 时间有两种限制方式：</p>
<ul>
<li>有多个 CPU 密集型的容器竞争 CPU 时，设置各个容器能使用的 CPU 时间相对比例。</li>
<li>以绝对的方式设置容器在每个调度周期内最多能使用的 CPU 时间。</li>
</ul>
<h2 id="磁盘IO配额控制"><a href="#磁盘IO配额控制" class="headerlink" title="磁盘IO配额控制"></a>磁盘IO配额控制</h2><p>相对于CPU和内存的配额控制，docker对磁盘IO的控制相对不成熟，大多数都必须在有宿主机设备的情况下使用。主要包括以下参数：</p>
<ul>
<li>–device-read-bps：限制此设备上的读速度（bytes per second），单位可以是kb、mb或者gb。</li>
<li>–device-read-iops：通过每秒读IO次数来限制指定设备的读速度。</li>
<li>–device-write-bps ：限制此设备上的写速度（bytes per second），单位可以是kb、mb或者gb。</li>
<li>–device-write-iops：通过每秒写IO次数来限制指定设备的写速度。</li>
<li>–blkio-weight：容器默认磁盘IO的加权值，有效值范围为10-100。</li>
<li>–blkio-weight-device： 针对特定设备的IO加权控制。其格式为DEVICE_NAME:WEIGHT</li>
</ul>
<h2 id="磁盘空间限制"><a href="#磁盘空间限制" class="headerlink" title="磁盘空间限制"></a>磁盘空间限制</h2><p>在docker使用devicemapper作为存储驱动时，默认每个容器和镜像的最大大小为10G。如果需要调整，可以在daemon启动参数中，使用dm.basesize来指定，但需要注意的是，修改这个值，不仅仅需要重启docker daemon服务，还会导致宿主机上的所有本地镜像和容器都被清理掉。</p>
<p>使用aufs或者overlay等其他存储驱动时，没有这个限制。</p>
<h1 id="与虚拟机的对比"><a href="#与虚拟机的对比" class="headerlink" title="与虚拟机的对比"></a><strong>与虚拟机的对比</strong></h1><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><img src="http://7u2qr4.com1.z0.glb.clouddn.com/blog_%E5%9B%BE%E7%89%871.png" alt="对比"><br><img src="http://7u2qr4.com1.z0.glb.clouddn.com/blog_%E5%9B%BE%E7%89%872.png" alt="对比"></p>
<p>通过docker和虚拟机实现原理的比较，我们大致可以得出一些结论： </p>
<ol>
<li><p>docker有着比虚拟机更少的抽象层。由于docker不需要Hypervisor实现硬件资源虚拟化，运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有优势，具体的效率对比在下几个小节里给出。在IO设备虚拟化上，docker的镜像管理有多种方案，比如利用Aufs文件系统或者Device Mapper实现docker的文件管理，各种实现方案的效率略有不同。 </p>
</li>
<li><p>docker利用的是宿主机的内核，而不需要Guest OS。因此，当新建一个容器时，docker不需要和虚拟机一样重新加载一个操作系统内核。我们知道，引导、加载操作系统内核是一个比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载Guest OS，这个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统，则省略了这个过程，因此新建一个docker容器只需要几秒钟。另外，现代操作系统是复杂的系统，在一台物理机上新增加一个操作系统的资源开销是比较大的，因此，docker对比虚拟机在资源消耗上也占有比较大的优势。事实上，在一台物理机上我们可以很容易建立成百上千的容器，而只能建立几个虚拟机。</p>
</li>
</ol>
<h2 id="计算效率"><a href="#计算效率" class="headerlink" title="计算效率"></a>计算效率</h2><p><img src="http://7u2qr4.com1.z0.glb.clouddn.com/blog_%E5%9B%BE%E7%89%873.png" alt="计算效率"></p>
<p>可见docker相对于物理机其计算能力几乎没有损耗，而虚拟机对比物理机则有着非常明显的损耗。虚拟机的计算能力损耗在50%左右。 </p>
<p>为什么会有这么大的性能损耗呢？</p>
<blockquote>
<p>一方面是因为虚拟机增加了一层虚拟硬件层，运行在虚拟机上的应用程序在进行数值计算时是运行在Hypervisor虚拟的CPU上的</p>
<p>另外一方面是由于计算程序本身的特性导致的差异。虚拟机虚拟的cpu架构不同于实际cpu架构，数值计算程序一般针对特定的cpu架构有一定的优化措施，虚拟化使这些措施作废，甚至起到反效果。</p>
</blockquote>
<h2 id="内存访问效率"><a href="#内存访问效率" class="headerlink" title="内存访问效率"></a>内存访问效率</h2><p><img src="http://7u2qr4.com1.z0.glb.clouddn.com/blog_TimLine%E6%88%AA%E5%9B%BE20150226143346.png" alt="内存访问"></p>
<p>内存访问效率的比较相对比较复杂一点，主要是内存访问有多种场景： </p>
<blockquote>
<p>（1）大批量的，连续地址块的内存数据读写。这种测试环境下得到的性能数据是内存带宽，性能瓶颈主要在内存芯片的性能上； </p>
<p>（2）随机内存访问性能。这种测试环境下的性能数据主要与内存带宽、cache的命中率和虚拟地址与物理地址转换的效率等因素有关。 </p>
</blockquote>
<p>在应用程序内存访问上，虚拟机的应用程序要进行2次的虚拟内存到物理内存的映射，读写内存的代价比docker的应用程序高。 </p>
<h2 id="启动时间及资源耗费"><a href="#启动时间及资源耗费" class="headerlink" title="启动时间及资源耗费"></a>启动时间及资源耗费</h2><p>无论从启动时间还是从启动资源耗费角度来说。docker直接利用宿主机的系统内核，避免了虚拟机启动时所需的系统引导时间和操作系统运行的资源消耗。利用docker能在几秒钟之内启动大量的容器，这是虚拟机无法办到的。快速启动、低系统资源消耗的优点使docker在弹性云平台和自动运维系统方面有着很好的应用前景。</p>
<h2 id="Docker的劣势"><a href="#Docker的劣势" class="headerlink" title="Docker的劣势"></a>Docker的劣势</h2><ol>
<li><p>资源隔离方面不如虚拟机，docker是利用cgroup实现资源限制的，只能限制资源消耗的最大值，而不能隔绝其他程序占用自己的资源。 </p>
</li>
<li><p>安全性问题。docker目前并不能分辨具体执行指令的用户，只要一个用户拥有执行docker的权限，那么他就可以对docker的容器进行所有操作，不管该容器是否是由该用户创建。比如A和B都拥有执行docker的权限，由于docker的server端并不会具体判断docker cline是由哪个用户发起的，A可以删除B创建的容器，存在一定的安全风险。 </p>
</li>
<li><p>docker目前还在版本的快速更新中，细节功能调整比较大。一些核心模块依赖于高版本内核，存在版本兼容问题</p>
</li>
<li><p>真实投入生产，还需要多种开源组件和技术的支持，如kubernetes管理容器、etcd管理存储、应用打包技术dockerfile、容器间的网络管理flannel、私有仓库的构建、持续集成jenkins的结合、监控docker的工具等等。</p>
</li>
</ol>
<h1 id="Docker的应用场景"><a href="#Docker的应用场景" class="headerlink" title="Docker的应用场景"></a><strong>Docker的应用场景</strong></h1><h2 id="简化配置"><a href="#简化配置" class="headerlink" title="简化配置"></a>简化配置</h2><p>这是Docker公司宣传的Docker的主要使用场景。虚拟机的最大好处是能在你的硬件设施上运行各种配置不一样的平台（软件、系统），Docker在降低额外开销的情况下提供了同样的功能。它能让你将运行环境和配置放在代码中然后部署，同一个Docker的配置可以在不同的环境中使用，这样就降低了硬件要求和应用环境之间耦合度。</p>
<h2 id="代码流水线（Code-Pipeline）"><a href="#代码流水线（Code-Pipeline）" class="headerlink" title="代码流水线（Code Pipeline）"></a>代码流水线（Code Pipeline）</h2><p>管理前一个场景对于管理代码的流水线起到了很大的帮助。代码从开发者的机器到最终在生产环境上的部署，需要经过很多的中间环境。而每一个中间环境都有自己微小的差别，Docker给应用提供了一个从开发到上线均一致的环境，让代码的流水线变得简单不少。</p>
<h2 id="提高开发效率"><a href="#提高开发效率" class="headerlink" title="提高开发效率"></a>提高开发效率</h2><p>不同的开发环境中，我们都想把两件事做好。一是我们想让开发环境尽量贴近生产环境，二是我们想快速搭建开发环境。理想状态中，要达到第一个目标，我们需要将每一个服务都跑在独立的虚拟机中以便监控生产环境中服务的运行状态。然而，我们却不想每次都需要网络连接，每次重新编译的时候远程连接上去特别麻烦。这就是Docker做的特别好的地方，开发环境的机器通常内存比较小，之前使用虚拟的时候，我们经常需要为开发环境的机器加内存，而现在Docker可以轻易的让几十个服务在Docker中跑起来。</p>
<p>另外一个场景就是，比如要设置mips的编译环境，而宿主机是debian.有些优秀的工具只存在于gentoo平台，而gentoo又不好安装，我们使用docker只要从docker hub上面pull下镜像，就可以完美使用，这使得开发人员效率最大化。</p>
<h2 id="隔离应用"><a href="#隔离应用" class="headerlink" title="隔离应用"></a>隔离应用</h2><p>有很多种原因会让你选择在一个机器上运行不同的应用，比如之前提到的提高开发效率的场景等。我们经常需要考虑两点，一是因为要降低成本而进行服务器整合，二是将一个整体式的应用拆分成松耦合的单个服务（即微服务架构）。</p>
<p>在权衡资源隔离(比如限制应用最大内存使用量，或者资源加载隔离，彼此资源占用互相不影响等)和低消耗(虚拟化本身带来的损耗需要尽量的低)上，Docker很好的权衡了两者，即拥有不错的资源隔离能力，又有很低的虚拟化开销。</p>
<h2 id="整合服务器"><a href="#整合服务器" class="headerlink" title="整合服务器"></a>整合服务器</h2><p>正如通过虚拟机来整合多个应用，Docker隔离应用的能力使得Docker可以整合多个服务器以降低成本。由于没有多个操作系统的内存占用，以及能在多个实例之间共享没有使用的内存，Docker可以比虚拟机提供更好的服务器整合解决方案。</p>
<h2 id="调试能力"><a href="#调试能力" class="headerlink" title="调试能力"></a>调试能力</h2><p>Docker提供了很多的工具，这些工具不一定只是针对容器，但是却适用于容器。它们提供了很多的功能，包括可以为容器设置检查点、设置版本和查看两个容器之间的差别，这些特性可以帮助调试Bug。你可以在《Docker拯救世界》的文章中找到这一点的例证。</p>
<h2 id="多租户环境"><a href="#多租户环境" class="headerlink" title="多租户环境"></a>多租户环境</h2><p>另外一个Docker有意思的使用场景是在多租户的应用中，它可以避免关键应用的重写。我们一个特别的关于这个场景的例子是为IoT（译者注：物联网）的应用开发一个快速、易用的多租户环境。这种多租户的基本代码非常复杂，很难处理，重新规划这样一个应用不但消耗时间，也浪费金钱。使用Docker，可以为每一个租户的应用层的多个实例创建隔离的环境，这不仅简单而且成本低廉，当然这一切得益于Docker环境的启动速度和其高效的diff命令。你可以在这里了解关于此场景的更多信息。</p>
<h2 id="快速部署"><a href="#快速部署" class="headerlink" title="快速部署"></a>快速部署</h2><p>在虚拟机之前，引入新的硬件资源需要消耗几天的时间。Docker的虚拟化技术将这个时间降到了几分钟，Docker只是创建一个容器进程而无需启动操作系统，这个过程只需要秒级的时间。这正是Google和Facebook都看重的特性。你可以在数据中心创建销毁资源而无需担心重新启动带来的开销。通常数据中心的资源利用率只有30%，通过使用Docker并进行有效的资源分配可以提高资源的利用率。</p>
<h2 id="从轻量级工具、持续集成演进到微服务架构"><a href="#从轻量级工具、持续集成演进到微服务架构" class="headerlink" title="从轻量级工具、持续集成演进到微服务架构"></a>从轻量级工具、持续集成演进到微服务架构</h2><p>早在14年国内有一些公司，开始尝试docker，当时毕竟docker是一个新事物，很多新特性方面的优点，并没有被大大的利用起来，这个也可以理解。那时docker对一些企业的价值在于计算的轻量级，也就是对于一些计算型的任务，通过docker的形式来分发，部署快，隔离性好，这样的任务包括：消息传递，图像处理等。</p>
<p>14下半年到15年初，docker的价值被更大化，应用的运行，服务的托管，外界的接受度也变高，国内也出现了一些startup公司，比如DaoCloud,灵雀云等。但这些仅仅是这些公司的第一步，后续紧跟的更多的是基于代码与镜像之间的CI/CD,缩减开发测试发布的流程，这方面的实践逐渐成熟。</p>
<p>微服务架构的兴起。微服务会对现阶段的软件架构有一些冲击，同样也是软件系统设计方法论的内容。这些方面国外讨论的要多一些，相信这一点也会近年来多家公司发力的地方。</p>
<h1 id="我们的需求及考虑"><a href="#我们的需求及考虑" class="headerlink" title="我们的需求及考虑"></a><strong>我们的需求及考虑</strong></h1><blockquote>
<ul>
<li><p>与硬件的解耦</p>
</li>
<li><p>硬件资源的最大化利用、应用与应用之间的安全隔离</p>
</li>
<li><p>开发与测试、外场环境的一致性</p>
</li>
<li><p>版本的快速分发和部署</p>
</li>
<li><p>微服务的引入</p>
</li>
</ul>
</blockquote>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Docker/" rel="tag"># Docker</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/08/10/Docker(二)环境搭建/" rel="next" title="Docker(二)环境搭建">
                <i class="fa fa-chevron-left"></i> Docker(二)环境搭建
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/08/10/Docker(三)常用操作/" rel="prev" title="Docker(三)常用操作">
                Docker(三)常用操作 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/daniuli.jpg"
               alt="LT" />
          <p class="site-author-name" itemprop="name">LT</p>
           
              <p class="site-description motion-element" itemprop="description">Just some notes.</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker简介"><span class="nav-number">1.</span> <span class="nav-text">Docker简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker自身的组件与元素"><span class="nav-number">2.</span> <span class="nav-text">Docker自身的组件与元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Docker-Client-amp-Docker-Daemon"><span class="nav-number">2.1.</span> <span class="nav-text">1. Docker Client & Docker Daemon</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Docker镜像"><span class="nav-number">2.2.</span> <span class="nav-text">2. Docker镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Docker容器"><span class="nav-number">2.3.</span> <span class="nav-text">5. Docker容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Docker仓库"><span class="nav-number">2.4.</span> <span class="nav-text">6. Docker仓库</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker的运行流程"><span class="nav-number">3.</span> <span class="nav-text">Docker的运行流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker的组网"><span class="nav-number">4.</span> <span class="nav-text">Docker的组网</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker运行时资源限制"><span class="nav-number">5.</span> <span class="nav-text">Docker运行时资源限制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#内存限制"><span class="nav-number">5.1.</span> <span class="nav-text">内存限制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU限制"><span class="nav-number">5.2.</span> <span class="nav-text">CPU限制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#磁盘IO配额控制"><span class="nav-number">5.3.</span> <span class="nav-text">磁盘IO配额控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#磁盘空间限制"><span class="nav-number">5.4.</span> <span class="nav-text">磁盘空间限制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#与虚拟机的对比"><span class="nav-number">6.</span> <span class="nav-text">与虚拟机的对比</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#实现原理"><span class="nav-number">6.1.</span> <span class="nav-text">实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算效率"><span class="nav-number">6.2.</span> <span class="nav-text">计算效率</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存访问效率"><span class="nav-number">6.3.</span> <span class="nav-text">内存访问效率</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#启动时间及资源耗费"><span class="nav-number">6.4.</span> <span class="nav-text">启动时间及资源耗费</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker的劣势"><span class="nav-number">6.5.</span> <span class="nav-text">Docker的劣势</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker的应用场景"><span class="nav-number">7.</span> <span class="nav-text">Docker的应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#简化配置"><span class="nav-number">7.1.</span> <span class="nav-text">简化配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代码流水线（Code-Pipeline）"><span class="nav-number">7.2.</span> <span class="nav-text">代码流水线（Code Pipeline）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#提高开发效率"><span class="nav-number">7.3.</span> <span class="nav-text">提高开发效率</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#隔离应用"><span class="nav-number">7.4.</span> <span class="nav-text">隔离应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#整合服务器"><span class="nav-number">7.5.</span> <span class="nav-text">整合服务器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调试能力"><span class="nav-number">7.6.</span> <span class="nav-text">调试能力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多租户环境"><span class="nav-number">7.7.</span> <span class="nav-text">多租户环境</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快速部署"><span class="nav-number">7.8.</span> <span class="nav-text">快速部署</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从轻量级工具、持续集成演进到微服务架构"><span class="nav-number">7.9.</span> <span class="nav-text">从轻量级工具、持续集成演进到微服务架构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#我们的需求及考虑"><span class="nav-number">8.</span> <span class="nav-text">我们的需求及考虑</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LT</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
